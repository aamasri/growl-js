{"version":3,"sources":["webpack:///./node_modules/@aamasri/dom-utils/dom-utils.js"],"names":["ready","Promise","resolve","document","readyState","$cache","addEventListener","loaded","window","selectorCache","hasOwnProperty","$body","length","$window","jQuery","$document","isInIframe","location","parent","cachedIsTouchDevice","isTouchDevice","DocumentTouch","query","split","join","matchMedia","matches","mq","isMobile","test","navigator","userAgent","toLowerCase","isVisible","el","getAppliedStyle","parseFloat","rect","getBoundingClientRect","top","left","bottom","innerHeight","documentElement","clientHeight","right","innerWidth","clientWidth","getViewportOffset","$element","console","error","offset","scroll","$win","scrollLeft","scrollTop","outerWidth","height","outerHeight","onTopZIndex","zTop","elements","getElementsByTagName","i","zIndex","getZIndex","element","recursive","parseInt","parentNode","style","getComputedStyle","getPropertyValue","async","webpSupport","self","createImageBitmap","blob","fetch","then","r","screenResolution","pixelDensity"],"mappings":"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","file":"chunk_dom-utils.js","sourcesContent":["/**\n * @fileOverview A collection of DOM utils to add syntactic sugar and supplement jQuery.\n * @author Ananda Masri\n * @version 1.0.2\n */\n\n\n\n/**\n * Defer execution until after document ready.\n *\n * Usage:\n *     import { ready } from 'dom-utils';\n *     ready().then(function() { ... });\n */\nexport const ready = () => new Promise((resolve) => {\n\tif (document.readyState !== 'loading')\n\t\tresolve($cache());\n\telse\n\t\tdocument.addEventListener('DOMContentLoaded', () => {\n\t\t\tresolve($cache());\n\t\t});\n});\n\n\n/**\n * Defer execution until after window has fully loaded (including images).\n *\n * Usage:\n * \t   import { loaded } from 'dom-utils';\n *     loaded().then(function() { ... });\n */\nexport const loaded = () => new Promise((resolve) => {\n\tif (document.readyState === 'complete')\n\t\tresolve($cache());\n\telse\n\t\twindow.addEventListener('load', () => {\n\t\t\tresolve($cache());\n\t\t});\n});\n\n\n\n\n// jQuery selector cache\n/**\n * Caches the jQuery window, document, & body elements.\n *\n * @returns {Object}\n */\nconst selectorCache = {};\nexport function $cache() {\n\tif (selectorCache.hasOwnProperty('$body') && selectorCache.$body.length)\n\t\treturn selectorCache;\n\n\tselectorCache.$window = jQuery(window);\n\tselectorCache.$document = jQuery(document);\n\tselectorCache.$body = jQuery('body');\n\n\treturn selectorCache;\n}\n\n\n\n/**\n * Whether the current window is actually a child window (contained in an iframe).\n *\n * @returns {boolean}\n */\nexport function isInIframe() {\n\treturn window.location !== window.parent.location;\n}\n\n\n/**\n * Whether this device has a touch screen.\n *\n * @returns {boolean}\n */\nlet cachedIsTouchDevice;\nexport function isTouchDevice() {\n\tif (typeof cachedIsTouchDevice === 'boolean')\n\t\treturn cachedIsTouchDevice;\n\n\tif (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {\n\t\tcachedIsTouchDevice = true;\n\t\treturn cachedIsTouchDevice;\n\t}\n\n\t// include the 'heartz' as a way to have a non matching MQ to help terminate the join\n\t// https://git.io/vznFH\n\tconst mq = function (query) {\n\t\tcachedIsTouchDevice = window.matchMedia(query).matches;\n\t\treturn cachedIsTouchDevice;\n\t};\n\n\tconst prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\n\tconst query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\n\tcachedIsTouchDevice = !!mq(query);\n\treturn cachedIsTouchDevice;\n}\n\n\n\n\n\n/**\n * Whether this device is a recognized mobile device.\n *\n * @returns {boolean}\n */\nexport function isMobile() {\n\treturn /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase());\n}\n\n\n\n\n\n/**\n * Whether the specified element is visible (ie. css display/visibility/opacity and viewport scroll position).\n *\n * @param {Element | Node | ParentNode | jQuery} el\n * @returns {boolean}\n */\nexport function isVisible(el) {\n\tif (el instanceof jQuery)\n\t\tel = el[0];\n\n\t//is object hidden\n\tif (getAppliedStyle(el, 'display') === 'none' || getAppliedStyle(el, 'visibility') === 'hidden' || parseFloat(getAppliedStyle(el, 'opacity')) < 0.1)\n\t\treturn false;\n\n\tconst rect = el.getBoundingClientRect();\n\treturn (\n\t\trect.top >= 0 &&\n\t\trect.left >= 0 &&\n\t\trect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n\t\trect.right <= (window.innerWidth || document.documentElement.clientWidth)\n\t);\n}\n\n\n\n\n\n/** Returns the specified element's offset from the visible viewport.\n *\n * @param {Element | Node | ParentNode | jQuery} $element\n * @returns {Object | undefined}\n */\nexport function getViewportOffset($element) {\n\t$element = jQuery($element);\t// convert to all element types to jQuery\n\tif (!$element.length) {\n\t\tconsole.error('function getViewportOffset(element) expects a DOM element or jQuery object!');\n\t\treturn undefined;\n\t}\n\n\tconst offset = $element.offset();\n\tconst scroll = {};\n\tconst $win = $cache().$window;\n\n\tscroll.left = $win.scrollLeft();\n\tscroll.top = $win.scrollTop();\n\n\tconst left = offset.left - scroll.left;\n\tconst top = offset.top - scroll.top;\n\tconst right = $win.outerWidth() - left - $element.outerWidth();\n\tconst bottom = $win.height() - top - $element.outerHeight();\n\n\treturn { top, right, bottom, left };\n}\n\n\n\n\n/** Get the highest z-index in the document.\n *\n * @returns {number}\n */\nexport function onTopZIndex() {\n\tlet zTop = 0;\n\tconst elements = document.getElementsByTagName('*');\n\n\tfor (let i = 0; i < elements.length; i++) {\n\t\tlet zIndex = getZIndex(elements[i]);\n\n\t\tif (zIndex && zIndex > zTop)\n\t\t\tzTop = zIndex;\n\t}\n\n\treturn zTop;\n}\n\n\n\n\n\n/**\n * Get the z-index of the the specified element.\n * The recursive option will traverse the parent tree (z-index includes descendents)\n *\n * @param {Element | Node | ParentNode} element\n * @param {boolean | undefined} [recursive=undefined] - whether to traverse parents in search of z-index\n * @returns {number} - the z-index\n */\nexport function getZIndex(element, recursive) {\n\tconst zIndex = parseInt(getAppliedStyle(element, 'z-Index')) || 0;\n\n\treturn (recursive && zIndex === 0) ? getZIndex(element.parentNode, true) : zIndex;\n}\n\n\n\n\n\n/**\n * Get the computed style of the the specified element and style.\n *\n * @param {Element | Node | ParentNode} element\n * @param {string} style - eg. 'z-index' or 'margin'\n * @returns {string} - the style value\n */\nexport function getAppliedStyle(element, style) {\n\treturn window.getComputedStyle(element).getPropertyValue(style);\n}\n\n\n\n\n\n/**\n * Whether the browser supports webp images.\n *\n * @returns {boolean}\n */\nexport async function webpSupport() {\n\tif (!self.createImageBitmap) return false;\n\n\tconst webpData = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=';\n\tconst blob = await fetch(webpData).then(r => r.blob());\n\treturn createImageBitmap(blob).then(() => true, () => false);\n}\n\n\n\n\n/**\n * Part of a system to determine the best image resolution for a given device.\n *\n * @returns {string} - lo|med|hi\n */\nexport function screenResolution() {\n\tconst pixelDensity = window.outerWidth * window.outerHeight;\n\t// iPhone SE:  320 x 568\t 182k\tlo\n\t// iPhone 8:   375 x 667     250k   lo\n\t// iPhone 8+:  414 x 736     305k   lo\n\t// iPad\":      768 x 1024    786k   med\n\t// iPad Pro+:  1024 x 1365   1.4M   med\n\t// my desktop: 1024 x 1920   2M     hi\n\t// my 4k:      3200 x 1800   5.8M   hi\n\n\tif (pixelDensity > 1500000)\n\t\treturn 'hi';\n\n\telse if (pixelDensity > 500000)\n\t\treturn 'med';\n\n\treturn 'lo';\n}"],"sourceRoot":""}